---
title: 자바스크립트 기본
date: '2024-01-30'
tags: ['react']
draft: false
summary: React 학습을 시작하기 이전에 필요한 ES6 JS 지식을 정리했습니다.
---

**교재 정보** [러닝 리액트](https://www.yes24.com/Product/Goods/102277805)

# 리액트를 위한 자바스크립트

## 변수 선언하기

### var, let, const

#### scope

```js
let let_1 = 'let_1'
var var_1 = 'var_1'

function foo() {
  let let_2 = 'let_2'
  var var_2 = 'var_2'

  if (true) {
    let let_3 = 'let_3'
    var var_3 = 'var_3'

    console.log(`[A] ${let_1}`)
    console.log(`[A] ${var_1}`)
    console.log(`[A] ${let_2}`)
    console.log(`[A] ${var_2}`)
    console.log(`[A] ${let_3}`)
    console.log(`[A] ${var_3}`)
  }

  console.log(`[B] ${let_1}`)
  console.log(`[B] ${var_1}`)
  console.log(`[B] ${let_2}`)
  console.log(`[B] ${var_2}`)
  /* 오류 */ console.log(`[B] ${let_3}`)
  console.log(`[B] ${var_3}`)
}

foo()

console.log(`[C] ${let_1}`)
console.log(`[C] ${var_1}`)
/* 오류 */ console.log(`[C] ${let_2}`)
/* 오류 */ console.log(`[C] ${var_2}`)
/* 오류 */ console.log(`[C] ${let_3}`)
/* 오류 */ console.log(`[C] ${var_3}`)
```

1. let, const: 블럭 단위 `if (true) {  }`
2. var: 함수 단위 `function foo() {  }`
3. `var` 사용 지양
4. 기본 자료형은 let을 사용.
5. 배열, 객체, 함수는 const를 사용.
   (참조변수에는 해당 값의 주소만 저장될 뿐이고, const로 변수를 선언해도 요소의 값은 변경할 수 있다.)

### 함수 표현식

1. `function hey()`: 함수 선언, 호이스팅 O
   `const hey = () => { }`: 함수 표현식, 호이스팅 X

```js
hey1()

function hey1() {
  console.log('Hey1!')
}

hey2()

const hey2 = () => {
  console.log('Hey2!')
}
```

```
Hey1!
ReferenceError: Cannot access 'hey2' before initialization
```

### 디폴트 파라미터

```js
function logActivity(name = '오성원', activity = '테니스') {
  console.log(`${name}은 ${activity}를 좋아합니다.`)
}

logActivity()
```

```js
const defaultPerson = {
  name: {
    first: '성원',
    last: '오',
  },
  favActivity: '테니스',
}
function logActivity(p = defaultPerson) {
  console.log(`${p.name.first}은(는) ${p.favActivity}를 좋아합니다.`)
}
logActivity()
```

### 화살표 함수

1. 일반 함수

```js
const lordify = function (firstname) {
  return `켄터베리의 ${firstname}`
}
console.log(lordify('오성원'))
console.log(lordify('오정원'))
```

2. 화살표 함수
   return문 하나만 있는 경우 `{ return }` 생략 가능

```js
const lordify = (firstName, land) => `${land}의 ${firstName}`
console.log(lordify('오성원', '브리즈번'))
console.log(lordify('오정원', '시드니'))
```

#### this

1. 일반 함수: this가 새로 바인딩된다.

```js
const gangwon = {
  resorts: ['용평', '평창', '강촌'],
  print: function (delay = 1000) {
    setTimeout(function () {
      console.log('this: ', this)
      console.log(this.resorts.join(','))
    }, delay)
  },
}

gangwon.print()
```

```
this:  Timeout { ... }
TypeError: Cannot read properties of undefined (reading 'join')
```

2. 화살표 함수: this를 새로 바인딩하지 않아 `gangwon` 객체를 잘 찾는다.

```js
const gangwon = {
  resorts: ['용평', '평창', '강촌'],
  print: function (delay = 1000) {
    setTimeout(() => {
      console.log('this: ', this)
      console.log(this.resorts.join(','))
    }, delay)
  },
}

gangwon.print()
```

```
this:  { resorts: [ '용평', '평창', '강촌' ], print: [Function: print] }
용평,평창,강촌
```

## Babel.js

1. ES6를 지원하지 않는 브라우저에서도 ES6 문법으로 작성한 코드를 그대로 실행할 수 있도록 ES5로 변환하는 컴파일러
2. 작성 예시
   ![Babel JS 작성 예시](/blogimage/basic-javascript-20240220-100222.png)
3. ES6

```js
const directions = (...args) => {
  console.log(`args: ${args}`)
  console.log(`drive through ${args.length} towns`)
  const [start, ...remaining] = args
  const [finish, ...stops] = remaining.reverse()
  console.log(`start in ${start}`)
  console.log(`the destination is ${finish}`)
  console.log(`stopping ${stops.length} times in between`)
}

directions('서울', '수원', '천안', '대전', '대구', '부산')
```

4. ES5

```js
function _toArray(arr) {
  return (
    _arrayWithHoles(arr) ||
    _iterableToArray(arr) ||
    _unsupportedIterableToArray(arr) ||
    _nonIterableRest()
  )
}
function _nonIterableRest() {
  throw new TypeError(
    'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return
  if (typeof o === 'string') return _arrayLikeToArray(o, minLen)
  var n = Object.prototype.toString.call(o).slice(8, -1)
  if (n === 'Object' && o.constructor) n = o.constructor.name
  if (n === 'Map' || n === 'Set') return Array.from(o)
  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen)
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]
  return arr2
}
function _iterableToArray(iter) {
  if (
    (typeof Symbol !== 'undefined' && iter[Symbol.iterator] != null) ||
    iter['@@iterator'] != null
  )
    return Array.from(iter)
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr
}
var directions = function directions() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key]
  }
  console.log('args: '.concat(args))
  console.log('drive through '.concat(args.length, ' towns'))
  var start = args[0],
    remaining = args.slice(1)
  var _remaining$reverse = remaining.reverse(),
    _remaining$reverse2 = _toArray(_remaining$reverse),
    finish = _remaining$reverse2[0],
    stops = _remaining$reverse2.slice(1)
  console.log('start in '.concat(start))
  console.log('the destination is '.concat(finish))
  console.log('stopping '.concat(stops.length, ' times in between'))
}
directions('서울', '수원', '천안', '대전', '대구', '부산')
```

## 객체와 배열

### 구조 분해

1. `{ value1, value2 } = object`
   `object`의 1번 key의 value를 `value1`에 저장하고, 2번 key의 value를 `value2`에 저장

```js
const sandwich = {
  bread: 'dutch crunch',
  meat: 'tuna',
  cheese: 'swiss',
  toppings: ['lettuce', 'tomato', 'mustard'],
}

let { bread, meat } = sandwich

console.log(sandwich)
console.log('bread: ' + bread)
console.log('meat: ' + meat)

bread = 'garlic'
meat = 'turkey'

console.log(sandwich)
console.log('bread: ' + bread)
console.log('meat: ' + meat)
console.log(sandwich.bread, sandwich.meat)
```

```
{
  bread: 'dutch crunch',
  meat: 'tuna',
  cheese: 'swiss',
  toppings: [ 'lettuce', 'tomato', 'mustard' ]
}
bread: dutch crunch
meat: tuna
{
  bread: 'dutch crunch',
  meat: 'tuna',
  cheese: 'swiss',
  toppings: [ 'lettuce', 'tomato', 'mustard' ]
}
bread: garlic
meat: turkey
dutch crunch tuna
```

2. `[value1] = array`
   `array`의 0번 요소를 `value1`에 저장

```js
const [firstAnimal] = ['Horse', 'Mouse', 'Cat']
console.log(firstAnimal)
```

```
Horse
```

3. `[, value1, value2] = array`
   `array`의 1번 요소를 `value1`에 저장
   `array`의 2번 요소를 `value2`에 저장

```js
const [, secondAnimal, thirdAnimal] = ['Horse', 'Mouse', 'Cat']
console.log(secondAnimal)
console.log(thirdAnimal)
```

```
Mouse
Cat
```

### 객체 리터럴 개선

1. 변수를 객체의 필드로 묶기

```js
const mountName = 'Mount Everest'
const elevation = 1234

const funHike = { mountName, elevation }

console.log(funHike)
```

```
{ mountName: 'Mount Everest', elevation: 1234 }
```

2. this 재할당 - `function` VS `=>`

```js
// 객체 리터럴 개선
const mountName = 'Mount Everest'
const elevation = 1234

const print_1 = function () {
  console.log('--- print_1 ---')
  console.log('this: ', this)
  console.log(`${this.mountName} is at ${this.elevation}`)
}

const print_2 = () => {
  console.log('--- print_2 ---')
  console.log('this: ', this)
  console.log(`${this.mountName} is at ${this.elevation}`)
}

const funHike = { mountName, elevation, print_1, print_2 }

funHike.print_1()
funHike.print_2()
```

```
--- print_1 ---
this:  {
  mountName: 'Mount Everest',
  elevation: 1234,
  print_1: [Function: print_1],
  print_2: [Function: print_2]
}
Mount Everest is at 1234
--- print_2 ---
this:  undefined
TypeError: Cannot read properties of undefined (reading 'mountName')
```

3. 이전 방식의 객체 리터럴

```js
const name = 'Léo Taillefer'
const sound = 'Kahh'
const skier = {
  name: name,
  sound: sound,
  powderYell: function () {
    var yell = this.sound.toUpperCase()
    console.log(`${yell} ${yell} ${yell}!!!`)
  },
  speed: function (mph) {
    this.speed = mph
    console.log('속력(mph):', mph)
  },
}

skier.powderYell()
skier.speed(350)
console.log(JSON.stringify(skier))
```

```
KAHH KAHH KAHH!!!
속력(mph): 350
{"name":"Léo Taillefer","sound":"Kahh","speed":350}
```

4. 개선된 방식의 객체 리터럴

```js
const name = 'Julia Mancuso'
const sound = 'Wooooh!'

const skier = {
  name,
  sound,
  powderYell() {
    let yell = this.sound.toUpperCase()
    console.log(`${yell} ${yell} ${yell}!!!`)
  },
  speed(mph) {
    this.speed = mph
    console.log('속력(mph):', mph)
  },
}

skier.powderYell()
skier.speed(185)
console.log(skier)
console.log(JSON.stringify(skier))
```

```
WOOOOH! WOOOOH! WOOOOH!!!!
속력(mph): 185
{
  name: 'Julia Mancuso',
  sound: 'Wooooh!',
  powderYell: [Function: powderYell],
  speed: 185
}
{"name":"Julia Mancuso","sound":"Wooooh!","speed":185}
```

### 스프레드 연산자

- 배열의 요소를 펼쳐서 개별적인 값으로 만든다.
- 배열의 요소를 복사할 때 사용한다.
- 배열의 요소를 병합할 때 사용한다.
- 배열의 요소를 함수의 매개변수로 전달할 때 사용한다.
- 배열의 요소를 객체의 키/값으로 사용할 때 사용한다.

1. 병합

```js
const peaks = ['대청봉', '중청봉', '소청봉']
const canyons = ['천불동계곡', '가야동계곡']
const seoraksan = [...peaks, ...canyons]
console.log(seoraksan)
```

```
[ '대청봉', '중청봉', '소청봉', '천불동계곡', '가야동계곡' ]
```

2. `reverse()`

```js
const peaks = ['대청봉', '중청봉', '소청봉']
const [last] = peaks.reverse()

console.log(last) // 소청봉
console.log(peaks)
console.log(peaks.join(', ')) // 소청봉, 중청봉, 대청봉
```

```
소청봉
[ '소청봉', '중청봉', '대청봉' ]
소청봉, 중청봉, 대청봉
```

3. `JSON.stringify()`

```js
const peaks = ['대청봉', '중청봉', '소청봉']
const [last] = [...peaks].reverse()

console.log(last) // 소청봉
console.log(peaks.join(', ')) // 대청봉, 중청봉, 소청봉
console.log(JSON.stringify(peaks))
```

```
소청봉
대청봉, 중청봉, 소청봉
["대청봉","중청봉","소청봉"]
```

4. 배열의 나머지 원소 얻기

```js
const lakes = ['Donner', 'Marlette', 'Fallen Leaf', 'Cascade']
const [first, ...rest] = lakes
console.log(rest.join(', '))
```

```
Marlette, Fallen Leaf, Cascade
```

5. 레스트 파라미터 rest parameters
   스프레드 연산자를 이용하여 여러 매개변수를 받아 배열로 바꾸기

```js
// 스프레드 연산자로 인자를 배열로 바꾸기

function directions(...args) {
  const [start, ...remaining] = args
  const [finish, ...stops] = remaining.reverse()

  console.log('args:', args)
  console.log(`args: ${args}`)
  console.log(`drive through ${args.length} towns`)
  console.log(`start in ${start}`)
  console.log(`the destination is ${finish}`)
  console.log(`stopping ${stops.length} times in between`)
}

directions('서울', '수원', '천안')
```

```
args: [ '서울', '수원', '천안' ]
args: 서울,수원,천안
drive through 3 towns
start in 서울
the destination is 천안
stopping 1 times in between
```

6. 객체에 대한 스프레드 연산자

```js
const twomeals = {
  breakfast: 'toast',
  lunch: 'rice',
}

const dinner = 'noodle'

const threemeals = {
  ...twomeals,
  dinner,
}

console.log('--- twomeals ---')
console.log(twomeals)
console.log('--- threemeals ---')
console.log(threemeals)
```

```
--- twomeals ---
{ breakfast: 'toast', lunch: 'rice' }
--- threemeals ---
{ breakfast: 'toast', lunch: 'rice', dinner: 'noodle' }
```

## 비동기 자바스크립트

1. 동기적 synchronous
   순차 실행, 완료되기까지 다른 작업을 수행할 수 없다.
2. 비동기적 asynchronous
   일단 제쳐 두고 다른 작업을 진행하다가 완료되면 처리한다.
3. `setTimeout()`

```js
console.log('A')
setTimeout(() => console.log('B'), 1000)
setTimeout(() => console.log('C'), 2000)
console.log('D')
```

```
A
D
B
C
```

- 크롬 브라우저의 V8 엔진이 B, C가 출력되기까지 가만히 대기하는 것이 아니라 일단 제쳐 두고 D 출력을 먼저 수행한다.

### Promise, fetch

1. 이전 `XMLHttpRequest()`

```js
const getFakeMembers = (count) =>
  new Promise((resolves, rejects) => {
    const api = `https://api.randomuser.me/?nat=US&results=${count}`
    const request = new XMLHttpRequest()
    request.open('GET', api)
    request.onload = () =>
      request.status === 200
        ? resolves(JSON.parse(request.response).results)
        : reject(Error(request.statusText))
    request.onerror = (err) => rejects(err)
    request.send()
  })
getFakeMembers(1).then(
  (members) => console.log(members),
  (err) => console.error(new Error('randomuser.me에서 멤버를 가져올 수 없습니다.'))
)
```

```
[
    {
        "gender": "female",
        "name": {
            "title": "Miss",
            "first": "Crystal",
            "last": "Sims"
        },
        "location": {
            "street": {
                "number": 6755,
                "name": "Thornridge Cir"
            },
            "city": "Santa Maria",
            "state": "Oklahoma",
            "country": "United States",
            "postcode": 89509,
            "coordinates": {
                "latitude": "-7.7973",
                "longitude": "97.9365"
            },
            "timezone": {
                "offset": "+6:00",
                "description": "Almaty, Dhaka, Colombo"
            }
        },
        "email": "crystal.sims@example.com",
        "login": {
            "uuid": "3d5cadcb-ea37-487f-9924-361eaed9dffc",
            "username": "brownduck445",
            "password": "building",
            "salt": "QpEHE0fI",
            "md5": "e716107b3056c6702f77fea95ab1f464",
            "sha1": "dd335176163411f30c37e718a2f8e8a28263cee8",
            "sha256": "c2ea7a1d4d703e7e455aa68dcca0099bfecacd875187b8d00ad60f9b9cac88d7"
        },
        "dob": {
            "date": "1950-01-22T00:50:43.700Z",
            "age": 74
        },
        "registered": {
            "date": "2020-10-27T22:17:36.319Z",
            "age": 3
        },
        "phone": "(986) 899-7071",
        "cell": "(270) 798-3121",
        "id": {
            "name": "SSN",
            "value": "046-15-3998"
        },
        "picture": {
            "large": "https://randomuser.me/api/portraits/women/62.jpg",
            "medium": "https://randomuser.me/api/portraits/med/women/62.jpg",
            "thumbnail": "https://randomuser.me/api/portraits/thumb/women/62.jpg"
        },
        "nat": "US"
    }
]
```

2. 최신 `fetch()`

```js
const getFakeMembers = (count) =>
  fetch(`https://api.randomuser.me/?nat=US&results=${count}`)
    .then((response) => {
      console.log('--- response ---')
      console.log(response)
      return response.json()
    })
    .then((members) => {
      console.log('--- members ---')
      console.log(members)
    })
    .catch((err) => console.error(err))

getFakeMembers(2)
```

```
--- response ---
Response {
  [Symbol(realm)]: null,
  [Symbol(state)]: {
    aborted: false,
    rangeRequested: false,
    timingAllowPassed: true,
    requestIncludesCredentials: true,
    type: 'default',
    status: 200,
    timingInfo: {
      startTime: 57.2598,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: 57.2598,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 600,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    },
    cacheState: '',
    statusText: 'OK',
    headersList: HeadersList {
      cookies: null,
      [Symbol(headers map)]: [Map],
      [Symbol(headers map sorted)]: null
    },
    urlList: [ URL {} ],
    body: { stream: undefined }
  },
  [Symbol(headers)]: HeadersList {
    cookies: null,
    [Symbol(headers map)]: Map(16) {
      'date' => [Object],
      'content-type' => [Object],
      'transfer-encoding' => [Object],
      'connection' => [Object],
      'x-powered-by' => [Object],
      'access-control-allow-origin' => [Object],
      'cache-control' => [Object],
      'etag' => [Object],
      'vary' => [Object],
      'cf-cache-status' => [Object],
      'report-to' => [Object],
      'nel' => [Object],
      'server' => [Object],
      'cf-ray' => [Object],
      'content-encoding' => [Object],
      'alt-svc' => [Object]
    },
    [Symbol(headers map sorted)]: null
  }
}
--- members ---
{
  results: [
    {
      gender: 'male',
      name: [Object],
      location: [Object],
      email: 'luis.crawford@example.com',
      login: [Object],
      dob: [Object],
      registered: [Object],
      phone: '(758) 723-3841',
      cell: '(670) 467-2231',
      id: [Object],
      picture: [Object],
      nat: 'US'
    },
    {
      gender: 'female',
      name: [Object],
      location: [Object],
      email: 'ruby.hunter@example.com',
      login: [Object],
      dob: [Object],
      registered: [Object],
      phone: '(319) 222-4403',
      cell: '(317) 695-5508',
      id: [Object],
      picture: [Object],
      nat: 'US'
    }
  ],
  info: { seed: 'a7e5d0251c482553', results: 2, page: 1, version: '1.4' }
}
```

3. 내가 만들어 본 예제
   도시 이름 입력하면 국가명, 위도, 경도 출력하기

- MySQL에 국가, 도시 정보 입력

```sql
CREATE TABLE countries (
    country_id CHAR(2) NOT NULL UNIQUE CHECK (REGEXP_LIKE(country_id, '[A-Z]{2}')),
    country_name VARCHAR(50) NOT NULL UNIQUE,
    continent_id CHAR(2) NOT NULL CHECK (
        continent_id IN ('AF', 'AN', 'AS', 'EU', 'NA', 'OC', 'SA')
    ),
    PRIMARY KEY (country_id)
);

CREATE TABLE cities (
    city_id INT NOT NULL UNIQUE,
    country_id CHAR(2) NOT NULL CHECK (REGEXP_LIKE(country_id, '[A-Z]{2}')),
    city_name VARCHAR(50) NOT NULL,
    latitude DECIMAL(7, 4) NOT NULL,
    longitude DECIMAL(7, 4) NOT NULL,
    timezone INT NOT NULL,
    PRIMARY KEY (city_id),
    FOREIGN KEY (country_id) REFERENCES countries(country_id)
);

INSERT INTO countries VALUES ('KR', 'Korea, Republic of', 'AS');

INSERT INTO cities VALUES (1835848, 'KR', 'Seoul', 37.5683, 126.9778, 32400);
```

- Node.js에서 GET("/") 요청에 대해 HTML 뷰를 표시하고 POST("/cities") 요청에 대해 도시 정보 JSON을 출력하는 컨트롤러 만들기

```js
import express from 'express'
import { createConnection } from 'mysql2'

const app = express()
const port = 80

app.use(express.json())

// MySQL 연결 구성
const db = createConnection({
  host: 'MYSQL_ADDRESS',
  user: 'MYSQL_USERNAME',
  password: 'MYSQL_PASSWORD',
  database: 'MYSQL_DATABASE',
})

// MySQL 연결하기
db.connect((err) => {
  if (err) {
    console.error('Error connecting to MySQL:', err)
  } else {
    console.log('Connected to MySQL')
  }
})

app.get('/', (req, res) => {
  // GET("/") 요청 시 form 송출
  const searchForm = `
  <!DOCTYPE html>
<html lang="ko">
  <head>
    <meta
      charset="UTF-8"
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Search City Name</title>
    <style>
      body {
        font-family: sans-serif;
      }
      form {
        margin-bottom: 20px;
      }
      label {
        font-size: 1.2em;
        margin-bottom: 10px;
      }
      input[type="text"] {
        width: 200px;
        padding: 5px;
        font-size: 1.2em;
      }
      button {
        padding: 5px 10px;
        font-size: 1.2em;
      }
      #searchResult {
        font-size: 1.2em;
      }
    </style>
  </head>

  <body>
    <form id="citySearchForm">
      <label for="cityName">City Name</label>
      <input type="text" id="cityName" name="name" required />
      <button type="submit">Search</button>
    </form>

    <div id="searchResult"></div>

    <script>
      document
        .getElementById("citySearchForm")
        .addEventListener("submit", function (event) {
          event.preventDefault();

          const cityName = document.getElementById("cityName").value;
          // Ajax POST request to "/cities"
          fetch("/cities", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ name: cityName }),
          })
            .then((response) => response.json())
            .then((results) => {
              // Update the result on the page
              const searchResultDiv = document.getElementById("searchResult");
              searchResultDiv.innerHTML = JSON.stringify(results);
            })
            .catch((error) => {
              console.error("Error:", error);
            });
        });
    </script>
  </body>
</html>
  `
  res.send(searchForm)
})

// POST("/cities") 요청
// 입력 JSON: {name: "Seoul"}
// 출력 JSON: [{"country_name":"Korea, Republic of","latitude":"37.5683","longitude":"126.9778"}]
app.post('/cities', (req, res) => {
  const city_name = req.body.name
  let query =
    'SELECT country_name, latitude, longitude FROM cities JOIN countries USING (country_id)'

  if (city_name) {
    query += ` WHERE city_name = '${city_name}'`
  }

  // SQL 실행
  db.query(query, (err, results) => {
    if (err) {
      console.error('Error executing query:', err)
      res.status(500).json({ error: 'Internal Server Error' })
    } else {
      // SELECT문 실행 결과를 JSON으로 변환하여 응답
      res.json(results)
    }
  })
})

// 서버 실행
app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`)
})
```

- http://127.0.0.1/ 접속하여 테스트하기
  ![Seoul JSON 데이터 출력](/blogimage/basic-javascript-20240220-100308.gif)

### async, await

1. then 함수를 연쇄 호출해 프라미스의 결과를 기다리는 대신，async 함수는 프라미스 다음에 있는 코드를 실행하기 전에 프라미스가 끝날 때까지 기다리라고 명령할 수 있다.

```js
const getFakePerson = async (count) => {
  const response = await fetch(`https://api.randomuser.me/?nat=US&results=${count}`)
  const { results } = await response.json()
  console.log(results)
}

getFakePerson(1)
```

```
[
  {
    gender: 'male',
    name: { title: 'Mr', first: 'Kirk', last: 'Turner' },
    location: {
      street: [Object],
      city: 'Lansing',
      state: 'Ohio',
      country: 'United States',
      postcode: 11579,
      coordinates: [Object],
      timezone: [Object]
    },
    email: 'kirk.turner@example.com',
    login: {
      uuid: '9ed2d7a0-a66f-4030-865e-5df0f59cfde6',
      username: 'goldentiger414',
      password: 'gotyoass',
      salt: 'Nxy0bnbr',
      md5: '9e7a0b4c2c17e5c598558ab4cfe70fc7',
      sha1: '83f3c2633769c37c447a939b506e15600b3f6baf',
      sha256: '274524ef01338983886e69428c59667e9710243e1ead164a5f2636aeda67ae4f'
    },
    dob: { date: '1994-02-05T05:49:45.058Z', age: 29 },
    registered: { date: '2021-06-17T18:08:16.495Z', age: 2 },
    phone: '(936) 898-8343',
    cell: '(656) 831-8420',
    id: { name: 'SSN', value: '565-02-5566' },
    picture: {
      large: 'https://randomuser.me/api/portraits/men/6.jpg',
      medium: 'https://randomuser.me/api/portraits/med/men/6.jpg',
      thumbnail: 'https://randomuser.me/api/portraits/thumb/men/6.jpg'
    },
    nat: 'US'
  }
]
```

## 클래스

1. 이전 `prototype`

```js
function Vacation(destination, length) {
  this.destination = destination
  this.length = length
}

Vacation.prototype.print = function () {
  console.log(this.destination + '은(는) ' + this.length + '일 걸립니다.')
}

var maui = new Vacation('마우이', 7)

maui.print()
```

```
마우이은(는) 7일 걸립니다.
```

2. 최신 `class`

```js
// 클래스를 사용해 정의하는 새로운 방식
class Vacation {
  constructor(destination, length) {
    this.destination = destination
    this.length = length
  }
  print() {
    console.log(`${this.destination}은(는) ${this.length}일 걸립니다.`)
  }
}

const trip = new Vacation('Santiago, Chile', 7)
trip.print()
```

```
Santiago, Chile은(는) 7일 걸립니다.
```

3. 상속

```js
class Vacation {
  constructor(destination, length) {
    this.destination = destination
    this.length = length
  }

  print() {
    console.log(this.destination + '은(는) ' + this.length + '일 걸립니다.')
  }
}

class Expedition extends Vacation {
  constructor(destination, length, gear) {
    super(destination, length)
    this.gear = gear
  }

  print() {
    super.print()
    console.log(`당신의 ${this.gear.join('와(과) 당신의 ')}를(을) 가져오십시오.`)
  }
}

const trip = new Expedition('한라산', 3, ['선글라스', '오색 깃발', '카메라'])

trip.print()
```

```
한라산은(는) 3일 걸립니다.
당신의 선글라스와(과) 당신의 오색 깃발와(과)
당신의 카메라를(을) 가져오십시오.
```

## 모듈

```js
// printer.js
// 자바스크립트의 모듈 문법은 기본적으로
// export, import 키워드를 사용한다.
export const title = 'kosmoPrinter'

export function print(str) {
  console.log(`[${title}] ${str}`)
}

// export default 키워드를 사용하면
// 기본으로 export 하는 것으로 설정된다.
export function defaultPrint(str) {
  console.log(`[default] ${str}`)
}

export default defaultPrint
```

```js
// printer-test.js
import { title, print as showPrint, defaultPrint as newDefaultPrint } from './printer.js'

showPrint('Hello, ES6 Module!')
console.log('title: ', title)
newDefaultPrint('Hello, default ES6 Module!')
```

# 자바스크립트를 활용한 함수형 프로그래밍

## 함수형

1. 정수나 문자열과 같은 다른 일반적인 값과 마찬가지로 함수를 취급할 수 있다는 뜻

```js
var log = function (message) {
  console.log(message)
}

log('자바스크립트에서는 함수를 변수에 넣을 수 있다.')
```

```
자바스크립트에서는 함수를 변수에 넣을 수 있다.
```

```js
const log = (message) => console.log(message)

log('ES6 화살표 함수')
```

```
ES6 화살표 함수
```

```js
const obj = {
  message: '함수를 다른 값과 마찬가지로 객체에 추가할 수도 있습니다.',
  log(message) {
    console.log(message)
  },
}

obj.log(obj.message)
```

```
함수를 다른 값과 마찬가지로 객체에 추가할 수도 있습니다.
```

```js
const messages = [
  '함수를 배열에 넣을 수도 있습니다.',
  (message) => console.log(message),
  '일반적인 값과 마찬가지입니다.',
  (message) => console.log(message),
]

messages[1](messages[0])
messages[3](messages[2])
```

```
함수를 배열에 넣을 수도 있습니다.
일반적인 값과 마찬가지입니다.
```

```js
const insideFn = (logger) => logger('함수를 다른 함수에 인자로 넘길 수도 있습니다.')

insideFn((message) => console.log(message))
```

```
함수를 다른 함수에 인자로 넘길 수도 있습니다.
```

```js
var createScream = function (logger) {
  return function (message) {
    logger(message.toUpperCase() + '!!!')
  }
}

const scream = createScream((message) => console.log(message))

scream('함수가 함수를 반환할 수도 있습니다')
scream('createScream은 함수를 반환합니다')
scream('scream은 createScream이 반환한 함수를 가리킵니다')
```

```
함수가 함수를 반환할 수도 있습니다!!!
CREATESCREAM은 함수를 반환합니다!!!
SCREAM은 CREATESCREAM이 반환한 함수를 가리킵니다!!!
```

```js
const createScream = (logger) => (message) => logger(message.toUpperCase() + '!!!')

const scream = createScream((message) => console.log(message))

scream('ES6에서는 더 간편하게 createScream을 만들 수 있습니다.')
```

```
ES6에서는 더 간편하게 CREATESCREAM을 만들 수 있습니다.!!!
```

## 명령형, 선언형

1. 선언적 프로그래밍: 필요한 것을 달성하는 과정을 기술하기보다 필요한 것이 어떤 것인지를 기술하며 앱의 구조를 세워 나가는 스타일
2. 선언적 프로그램은 코드 자체가 어떤 일이 벌어질지에 대해 설명하기 때문에 좀 더 추론하기가 쉽다.

### 공백을 하이픈으로 바꾸기

#### 명령형

```js
var string = 'This is the mid day show with Cheryl Waters'
var urlFriendly = ''

for (var i = 0; i < string.length; i++) {
  if (string[i] === ' ') {
    urlFriendly += '-'
  } else {
    urlFriendly += string[i]
  }
}

urlFriendly = urlFriendly.toLowerCase()

console.log(urlFriendly)
```

```
this-is-the-mid-day-show-with-cheryl-waters
```

#### 선언형

```js
const string = 'This is the mid day show with Cheryl Waters'
const urlFriendly = string.replace(/ /g, '-').toLowerCase()

console.log(urlFriendly)
```

```
this-is-the-mid-day-show-with-cheryl-waters
```

**`/ /g` 정규식**

- `/ /` - 단일 공백 문자
- `g` - global: 처음 1개만 바꾸지 말고 모두 바꾸기

### Hello World

### 명령형

```html
<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hello</title>
  </head>

  <body>
    <div id="target"></div>
    <script>
      var target = document.getElementById('target')
      var wrapper = document.createElement('div')
      var headline = document.createElement('hl')
      wrapper.id = 'welcome'
      headline.innerText = 'Hello World'
      wrapper.appendChild(headline)
      target.appendChild(wrapper)
    </script>
  </body>
</html>
```

### 선언형

```js
const { render } = ReactDOM

const Welcome = () => (
  <div id="welcome">
    <h1>Hello World</h1>
  </div>
)

render(<Welcome />, document.getElementByld('target'))
```

## 함수형 프로그래밍의 개념

### 불변성

원본 데이터 구조를 변경하는 대신 복사본을 만들어 일부를 변경하여 작업을 진행한다

1. 변하는 예시

```js
let color_lawn = {
  title: '잔디',
  color: '#00FF00',
  rating: 0,
}

function rateColor(color, rating) {
  color.rating = rating
  return color
}

console.log(rateColor(color_lawn, 5).rating)
console.log(color_lawn.rating)
```

```
5
5
```

2. 불변하는 예시: `Object.assign()` 이용

```js
let color_lawn = {
  title: '잔디',
  color: '#00FF00',
  rating: 0,
}

var rateColor = function (color, rating) {
  return Object.assign({}, color, { rating: rating })
}

// Object.assign으로 복사본을 만들어서 평점을 부여한다

console.log(rateColor(color_lawn, 5).rating)
console.log(color_lawn.rating)
```

```
5
0
```

3. 불변하는 예시: 스프레드 연산자 `...` 이용

```js
let color_lawn = {
  title: '잔디',
  color: '#00FF00',
  rating: 0,
}

// return 객체: { }를 사용하여 묶어 준다
const rateColor = (color, rating) => ({
  ...color,
  rating,
})

// 더 나은 방법으로 객체 스프레드 ...를 사용한다

console.log(rateColor(color_lawn, 5).rating)
/* {
  title: '잔디',
  color: '#00FF00',
  rating: --> 5
} */
console.log(color_lawn.rating)
/* {
  title: "잔디",
  color: "#00FF00",
  rating: --> 0,
} */
```

```
5
0
```

4. 변하는 예시: `array.push()`

```js
let list = [{ title: '과격한 빨강' }, { title: '잔디' }, { title: '파티 핑크' }]

var addColor = function (title, colors) {
  colors.push({ title: title })
  return colors
}

// 색을 추가하면 원래의 배열이 바뀐다

console.log(addColor('매력적인 초록', list).length)
console.log(list.length)
```

```
4
4
```

5. 불변하는 예시: `array.concat()`

```js
let list = [{ title: '과격한 빨강' }, { title: '잔디' }, { title: '파티 핑크' }]

const addColor = (title, array) => array.concat({ title })

// array.concat을 사용하면 원래의 배열이 변경되지 않는다

console.log(addColor('매력적인 초록', list).length)
console.log(list.length)
```

```
4
3
```

6. 불변하는 예시: 스프레드 연산자 `...`

```js
let list = [{ title: '과격한 빨강' }, { title: '잔디' }, { title: '파티 핑크' }]

const addColor = (title, list) => [...list, { title }]

// ... 스프레드 연산자로 배열을 복사하면 더 편리하다

console.log(addColor('매력적인 초록', list).length)
console.log(list.length)
```

```
4
3
```

### 순수 함수

1. 파라미터에 의해서만 반환값이 결정되는 함수
2. 최소 1개의 파라미터를 받고, 파라미터가 모두 같으면 항상 같은 값이나 함수를 반환한다.
3. 부수 효과가 없다.
4. 부수 효과: 전역 변수를 설정하거나, 애플리케이션에 있는 다른 상태(변수)를 변경하는 것
5. 순수하지 않은 함수

- 인자도 없고, return문도 없으며, 원본 객체 변경도 발생한다.

```js
var frederick = {
  name: 'Frederick Douglass',
  canRead: false,
  canWrite: false,
}

function selfEducate() {
  frederick.canRead = true
  frederick.canWrite = true
}

selfEducate()

console.log(frederick)
```

```
{ name: 'Frederick Douglass', canRead: true, canWrite: true }
```

6. 순수하지 않은 함수

- 인자가 있고, return문이 있지만, 원본 객체를 변화시킨다.

```js
var frederick = {
  name: 'Frederick Douglass',
  canRead: false,
  canWrite: false,
}

const selfEducate = (person) => {
  person.canRead = true
  person.canWrite = true
  return person
}

console.log(selfEducate(frederick))
console.log(frederick)
```

```
{ name: 'Frederick Douglass', canRead: true, canWrite: true }
{ name: 'Frederick Douglass', canRead: true, canWrite: true }
```

7. 순수 함수

```js
var frederick = {
  name: 'Frederick Douglass',
  canRead: false,
  canWrite: false,
}

const selfEducate = (person) => ({
  ...person,
  canRead: true,
  canWrite: true,
})

console.log(selfEducate(frederick))
console.log(frederick)
```

```
{ name: 'Frederick Douglass', canRead: true, canWrite: true }
{ name: 'Frederick Douglass', canRead: false, canWrite: false }
```

8. 순수하지 않은 함수

- DOM 원본을 변경한다
- return문이 없다

```html
<!doctype html>
<html>
  <head>
    <meta
      name="viewport"
      content="minimum-scale=1.0, width=device-width, maximum-scale=1.0, user-scalable=no"
    />
    <meta charset="utf-8" />
    <title>Pure Functions</title>
  </head>
  <body>
    <h1>Pure Functions</h1>
    <script>
      function Header(text) {
        let h1 = document.createElement('h1')
        h1.innerText = text
        document.body.appendChild(h1)
      }

      Header('Header() caused side effects')
    </script>
  </body>
</html>
```

![순수하지 않은 함수 출력 결과](/blogimage/basic-javascript-20240220-100414.png)

9. 순수 함수

- DOM 원본을 변경하지 않는다.
- return문이 있다.

```html
<!doctype html>
<html>
  <head>
    <meta
      name="viewport"
      content="minimum-scale=1.0, width=device-width, maximum-scale=1.0, user-scalable=no"
    />
    <meta charset="utf-8" />
    <title>Pure Functions</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
  </head>
  <body>
    <h1>Pure Functions</h1>
    <div id="react-container"></div>
    <script type="text/babel">
      const Header = (props) => <h1>{props.title}</h1>

      ReactDOM.render(
        <Header title="React uses pure functions" />,
        document.getElementById('react-container')
      )
    </script>
  </body>
</html>
```

![순수 함수 출력 결과](/blogimage/basic-javascript-20240220-100450.png)

### 데이터 변환

한 유형의 데이터를 다른 유형으로 변경하는 함수

#### `Array.join()`

- 원본 배열 보존 -> `,` 연결 문자열 반환

```js
const schools = ['Yorktown', 'Washington & Lee', 'Wakefield']

console.log(schools.join(', '))
```

```
Yorktown, Washington & Lee, Wakefield
```

#### `Array.filter()`

- 원본 배열 보존 -> 새로운 배열 반환

```js
const schools = ['Yorktown', 'Washington & Lee', 'Wakefield']

const wSchools = schools.filter((school) => school[0] === 'W')

console.log(wSchools)
```

```
[ 'Washington & Lee', 'Wakefield' ]
```

- `filter()` 및 `join()` 같이 쓰기

```js
const schools = ['Yorktown', 'Washington & Lee', 'Wakefield']

const cutSchool = (cut, list) => list.filter((school) => school !== cut)

console.log(cutSchool('Washington & Lee', schools).join(' * '))
console.log(schools.join('\n'))
```

```
Yorktown * Wakefield
Yorktown
Washington & Lee
Wakefield
```

#### `Array.map()`

- 원본 배열 보존 -> 배열의 모든 원소에 함수를 적용한 값으로 이뤄진 새 배열 반환

```js
const schools = ['Yorktown', 'Washington & Lee', 'Wakefield']

const highSchools = schools.map((school) => `${school} High School`)

console.log('--- highSchools ---')
console.log(highSchools.join('\n'))
console.log('--- schools ---')
console.log(schools.join('\n'))
```

```
Yorktown High School
Washington & Lee High School
Wakefield High School
--- schools ---
Yorktown
Washington & Lee
Wakefield
```

```js
const schools = ['Yorktown', 'Washington & Lee', 'Wakefield']

const highSchools = schools.map((school) => ({ name: school }))

console.log(highSchools)
```

```
[
  { name: 'Yorktown' },
  { name: 'Washington & Lee' },
  { name: 'Wakefield' }
]
```

```js
// 4개의 객체를 요소로 갖는 배열을 선언합니다.
let schools = [
  { name: 'Yorktown' },
  { name: 'Stratford' },
  { name: 'Washington & Lee' },
  { name: 'Wakefield' },
]

const editName = (oldName, name, arr) =>
  // item = arr 배열의 각 요소
  // {name: "어쩌구"} 형태의 객체
  arr.map((item) => {
    if (item.name === oldName) {
      console.log('found item: ', item)
      return {
        ...item,
        // {name: ?} -> ? 부분에 name 변수의 값이 들어갑니다.
        // name: name -> name으로 생략 가능
        name: name,
      }
    } else {
      return item
    }
  })

let updatedSchools = editName('Stratford', 'HB Woodlawn', schools)

console.log('after: ', updatedSchools[1])
console.log('before: ', schools[1])
```

```
found item:  { name: 'Stratford' }
after:  { name: 'HB Woodlawn' }
before:  { name: 'Stratford' }
```

```js
// 이전 예제의 if문을 ? 연산자로 바꾸면 다음과 같다.
let schools = [
  { name: 'Yorktown' },
  { name: 'Stratford' },
  { name: 'Washington & Lee' },
  { name: 'Wakefield' },
]

const editName = (oldName, name, arr) =>
  arr.map((item) => (item.name === oldName ? { ...item, name } : item))

let updatedSchools = editName('Stratford', 'HB Woodlawn', schools)

console.log(updatedSchools[1])
console.log(schools[1])
```

```
{ name: 'HB Woodlawn' }
{ name: 'Stratford' }
```

```js
// Object.keys()
// 객체 배열을 key + value 형식으로 변환하기
const schools = {
  Yorktown: 10,
  'Washington & Lee': 2,
  Wakefield: 5,
}

const schoolArray = Object.keys(schools).map((key) => ({
  name: key,
  wins: schools[key],
}))

console.log(schoolArray)
```

```
[
  { name: 'Yorktown', wins: 10 },
  { name: 'Washington & Lee', wins: 2 },
  { name: 'Wakefield', wins: 5 }
]
```

#### `Array.reduce()`

- 배열의 각 요소에 대해 주어진 함수를 실행하고,
- 하나의 결과값을 반환한다.
- 배열 요소들의 총합, 평균, 최댓값 등을 구할 때 사용한다.
- 기본 문법

```js
array.reduce(callback(accumulator, currentValue, index, array), initialValue)
배열.reduce(callback(누적값, 현재값, 인덱스, 요소), 초기값)
```

- 배열에서 최댓값 구하기

```js
const ages = [21, 18, 42, 40, 64, 63, 34]

const maxAge = ages.reduce((max, age) => {
  console.log(`${age} > ${max} = ${age > max}`)
  if (age > max) {
    return age
  } else {
    return max
  }
}, 0)

console.log('maxAge: ', maxAge)

const arr = [1, 2, 3, 4, 5]

const sum = arr.reduce(function (acc, cur, idx) {
  console.log(acc, cur, idx)
  return acc + cur
}, 0)

console.log('sum: ', sum)
```

```
21 > 0 = true
18 > 21 = false
42 > 21 = true
40 > 42 = false
64 > 42 = true
63 > 64 = false
34 > 64 = false
maxAge:  64
0 1 0
1 2 1
3 3 2
6 4 3
10 5 4
sum:  15
```

```js
const ages = [21, 18, 42, 40, 64, 63, 34]

const max = ages.reduce((max, value) => (value > max ? value : max), 0)

console.log('max', max)
```

```
max 64
```

- 특정 key-value를 밖으로 꺼내기

```js
const colors = [
  {
    id: '-xekare',
    title: '과격한 빨강',
    rating: 3,
  },
  {
    id: '-jbwsof',
    title: '큰 파랑',
    rating: 2,
  },
  {
    id: '-prigbj',
    title: '큰곰 회색',
    rating: 5,
  },
  {
    id: '-ryhbhsl',
    title: '바나나',
    rating: 1,
  },
]

const hashColors = colors.reduce((hash, { id, title, rating }) => {
  hash[id] = { title, rating }
  return hash
}, {})

console.log(hashColors)
```

```
{
  '-xekare': { title: '과격한 빨강', rating: 3 },
  '-jbwsof': { title: '큰 파랑', rating: 2 },
  '-prigbj': { title: '큰곰 회색', rating: 5 },
  '-ryhbhsl': { title: '바나나', rating: 1 }
}
```

- 중복 제거

```js
const colors = ['red', 'red', 'green', 'blue', 'green']

const distinctColors = colors.reduce(
  (distinct, color) =>
    // 누적값 distinct에 현재값 color가 있니?
    distinct.indexOf(color) !== -1
      ? // 있다면 그대로 반환해 주고
        distinct
      : // 없다면 distinct에 color를 추가해 반환해 주어라.
        [...distinct, color],
  []
)

console.log(distinctColors)
```

```
[ 'red', 'green', 'blue' ]
```

### 고차 함수

- 다른 함수를 조작할 수 있는 함수

#### 다른 함수를 인자로 받는 함수

```js
const invokeIf = (condition, fnTrue, fnFalse) => (condition ? fnTrue() : fnFalse())

const showWelcome = () => console.log('Welcome!!!')

const showUnauthorized = () => console.log('Unauthorized!!!')

invokeIf(true, showWelcome, showUnauthorized)
invokeIf(false, showWelcome, showUnauthorized)
```

```
Welcome!!!
Unauthorized!!!
```

#### 다른 함수를 반환하는 함수

- 커링 (Currying): 연산을 수행할 때 필요한 값 중 일부를 저장하고 나중에 나머지 값을 전달받는 기법
- `userLogs` 함수: `userName` 매개변수를 받아 익명 함수 `(message) => console.log()`를 반환한다. 커링된 함수 (Curried function)이다.

```js
const userLogs = (userName) => (message) => console.log(`${userName} -> ${message}`)

const log = userLogs('grandpa23')

log('attempted to load 20 fake members')
```

```
grandpa23 -> attempted to load 20 fake members
```

### 재귀

1. 10부터 1까지 출력하기

```js
const countdown = (value, fn) => {
  fn(value)
  return value > 0 ? countdown(value - 1, fn) : value
}

countdown(10, (value) => console.log(value))
```

```
10
9
8
7
6
5
4
3
2
1
0
```

2. `setTimeout()` 이용, 1초에 하나씩 출력하기

```js
const countdown = (value, fn, delay = 1000) => {
  fn(value)
  return value > 0 ? setTimeout(() => countdown(value - 1, fn), delay) : value
}

const log = (value) => console.log(value)
countdown(10, log)
```

```
10
9
8
7
6
5
4
3
2
1
0
```

3. 객체의 속성 찾기

```js
const dan = {
  type: 'person',
  data: {
    gender: 'male',
    info: {
      id: 22,
      fullname: {
        first: 'Dan',
        last: 'Deacon',
      },
    },
  },
}

const deepPick = (fields, object = {}) => {
  const [first, ...remaining] = fields.split('.')
  return remaining.length ? deepPick(remaining.join('.'), object[first]) : object[first]
}

// type 뒤 .이 없으므로 remaining.length = 0
// dan[type]을 출력
console.log(deepPick('type', dan))
console.log(deepPick('data.info.fullname.first', dan))
```

```
person
Dan
```

### 합성

1. 명령형 시계

```js
// 매 초 시간을 로그에 남긴다.
setInterval(logClockTime, 1000)

function logClockTime() {
  // 현재 시각을 상용시로 표현하는 문자열을 얻는다.
  var time = getClockTime()

  // 콘솔을 지우고 시간을 로그에 남긴다.
  console.clear()
  console.log(time)
}

function getClockTime() {
  // 현재 시각을 얻는다.
  var date = new Date()
  var time = ''

  // 시각을 직렬화한다.
  var time = {
    hours: date.getHours(),
    minutes: date.getMinutes(),
    seconds: date.getSeconds(),
    ampm: 'AM',
  }

  // 상용시로 변환한다.
  if (time.hours == 12) {
    time.ampm = 'PM'
  } else if (time.hours > 12) {
    time.ampm = 'PM'
    time.hours -= 12
  }

  // 시간을 2글자로 만들기 위해 앞에 0을 붙인다.
  if (time.hours < 10) {
    time.hours = '0' + time.hours
  }

  // 분을 2글자로 만들기 위해 앞에 0을 붙인다.
  if (time.minutes < 10) {
    time.minutes = '0' + time.minutes
  }

  // 초를 2글자로 만들기 위해 앞에 0을 붙인다.
  if (time.seconds < 10) {
    time.seconds = '0' + time.seconds
  }

  // "hh:mm:ss tt" 형식의 문자열을 만든다.
  return time.hours + ':' + time.minutes + ':' + time.seconds + ' ' + time.ampm
}
```

```
06:37:57 PM
```

2. 선언형 시계: `compose()` 함수를 이용한 함수 합성

```js
const oneSecond = () => 1000
const getCurrentTime = () => new Date()
const clear = () => console.clear()
const log = (message) => console.log(message)

const abstractClockTime = (date) => ({
  hours: date.getHours(),
  minutes: date.getMinutes(),
  seconds: date.getSeconds(),
})

const civilianHours = (clockTime) => ({
  ...clockTime,
  hours: clockTime.hours > 12 ? clockTime.hours - 12 : clockTime.hours,
})

const appendAMPM = (clockTime) => ({
  ...clockTime,
  ampm: clockTime.hours >= 12 ? 'PM' : 'AM',
})

const display = (target) => (time) => target(time)

const formatClock = (format) => (time) =>
  format
    .replace('hh', time.hours)
    .replace('mm', time.minutes)
    .replace('ss', time.seconds)
    .replace('tt', time.ampm)

const prependZero = (key) => (clockTime) => ({
  ...clockTime,
  [key]: clockTime[key] < 10 ? '0' + clockTime[key] : clockTime[key],
})

const compose =
  (...fns) =>
  (arg) =>
    fns.reduce((composed, f) => f(composed), arg)

const convertToCivilianTime = (clockTime) => compose(appendAMPM, civilianHours)(clockTime)

const doubleDigits = (civilianTime) =>
  compose(prependZero('hours'), prependZero('minutes'), prependZero('seconds'))(civilianTime)

const startTicking = () =>
  setInterval(
    compose(
      clear,
      getCurrentTime,
      abstractClockTime,
      convertToCivilianTime,
      doubleDigits,
      formatClock('hh:mm:ss tt'),
      display(log)
    ),
    oneSecond()
  )

startTicking()
```

```
06:38:40 PM
```
